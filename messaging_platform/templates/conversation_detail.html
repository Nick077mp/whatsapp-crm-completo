{% extends 'base.html' %}
{% load static %}
{% csrf_token %}
<meta name="csrf-token" content="{{ csrf_token }}">
{% block title %}Chat con {{ conversation.contact.display_name }} - Plataforma de Mensajer√≠a{% endblock %}

{% block extra_css %}
<style>
/* Variables CSS para consistencia */
:root {
    --primary-color: #007bff;
    --danger-color: #dc3545;
    --success-color: #28a745;
    --warning-color: #ffc107;
    --info-color: #17a2b8;
    --secondary-color: #6c757d;
    --light-color: #f8f9fa;
    --dark-color: #343a40;
    --border-color: #dee2e6;
}

/* Estilos del contenedor principal */
.conversation-detail-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 1rem;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    min-height: 80vh;
}

.conversation-header {
    background: var(--light-color);
    border-bottom: 1px solid var(--border-color);
    padding: 1rem;
    margin: -1rem -1rem 1rem -1rem;
    border-radius: 8px 8px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* Estilos de mensajes removido del container principal */

.message {
    margin-bottom: 1rem;
    padding: 0.75rem;
    border-radius: 8px;
    max-width: 70%;
}

.message-sent {
    background: var(--primary-color);
    color: white;
    margin-left: auto;
    text-align: left;
}

.message-received {
    background: white;
    border: 1px solid var(--border-color);
    margin-right: auto;
}

.message-header {
    font-size: 0.8rem;
    margin-bottom: 0.5rem;
    opacity: 0.8;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem; /* Espacio entre nombre y fecha */
}

.message-header strong {
    flex: 1; /* El nombre ocupa el espacio disponible */
}

.message-header .message-timestamp {
    flex-shrink: 0; /* La fecha mantiene su tama√±o */
    margin-left: auto; /* Empuja la fecha hacia la derecha */
}

.message-input-container {
    display: flex;
    gap: 1rem;
    align-items: flex-end;
}

.input-controls {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.message-input-wrapper {
    flex: 1;
}

#messageInput {
    width: 100%;
    min-height: 60px;
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    resize: vertical;
    font-family: inherit;
}

.btn {
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    text-decoration: none;
    display: inline-block;
    text-align: center;
    transition: all 0.3s ease;
}

.btn-primary {
    background: var(--primary-color);
    color: white;
}

.btn-primary:hover {
    background: #0056b3;
}

.btn-outline {
    background: transparent;
    border: 1px solid var(--border-color);
    color: var(--dark-color);
}

.btn-secondary {
    background: var(--secondary-color);
    color: white;
    font-size: 0.9rem;
    padding: 0.5rem 0.75rem;
}

.btn-secondary:hover {
    background: #545b62;
}

/* Alerta de tiempo de respuesta */
.response-time-alert {
    position: fixed;
    top: 80px;
    right: 20px;
    background: var(--warning-color);
    color: white;
    padding: 1rem 1.5rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 1000;
    display: none;
    animation: slideIn 0.3s ease;
    max-width: 300px;
}

.response-time-alert.danger {
    background: var(--danger-color);
}

.response-time-alert .close-alert {
    float: right;
    background: none;
    border: none;
    color: white;
    font-size: 1.2rem;
    cursor: pointer;
    margin-left: 10px;
}

@keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

.btn-whatsapp {
    background: #25d366;
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

/* Estilos para mejorar la visibilidad de timestamps y info de mensajes */
.message-header small,
.message-info small,
.message-timestamp {
    color: #555555 !important; /* Color m√°s oscuro y visible */
    font-weight: 500;
    font-size: 0.85rem;
}

.message-sent .message-header small,
.message-sent .message-info small {
    color: #444444 !important; /* A√∫n m√°s oscuro para mensajes enviados */
}

.message-received .message-header small,
.message-received .message-info small {
    color: #666666 !important; /* Color visible para mensajes recibidos */
}

/* Asegurar que el texto no sea muted en los mensajes */
.message .text-muted {
    color: #555555 !important;
}

/* üé¨ Animaciones para nuevos mensajes */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* üéØ Contenedor de mensajes - Con scroll normal y posicionamiento al final */
#messagesContainer {
    display: block; /* Cambiar a block para scroll normal */
    height: 500px; /* Altura fija para forzar scroll cuando sea necesario */
    max-height: 600px;
    overflow-y: scroll; /* Siempre mostrar barra de scroll */
    padding: 1rem;
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
}

/* Asegurar que los mensajes no se compriman */
.message {
    flex-shrink: 0;
}

/* Animaci√≥n para mensajes nuevos */
.message.new-message {
    animation: fadeInUp 0.4s ease-out;
}
</style>
{% endblock %}

{% block content %}
<div class="conversation-detail-container">
    <div class="conversation-header">
        <div class="header-left">
            <a href="{% url 'dashboard' %}" class="btn btn-outline">‚Üê Volver al Dashboard</a>
            <h3>{{ conversation.contact.display_name }}</h3>
            <span class="badge">{{ conversation.contact.platform.name|title }}</span>
            {% if conversation.contact.platform.name == 'whatsapp' %}
            <button class="btn-whatsapp" onclick="openWhatsApp('{{ conversation.contact.whatsapp_number|default:conversation.contact.platform_user_id }}')" title="Abrir en WhatsApp">
                üì± Abrir en WhatsApp
            </button>
            {% endif %}
        </div>
    </div>

    <div id="messagesContainer">
        {% for message in messages %}
        <div class="message {% if message.sender_type == 'agent' %}message-sent{% else %}message-received{% endif %}">
            <div class="message-header">
                <strong>{{ message.sender_name }}</strong>
                <small class="message-timestamp">{{ message.created_at|date:"d/m/Y, H:i" }}</small>
            </div>
            <div class="message-content">
                {{ message.content }}
                {% if message.media_url %}
                    {% if message.message_type == 'image' %}
                        <div class="media-container">
                            <img src="{{ message.media_url }}" alt="Imagen" style="max-width: 200px; border-radius: 4px;">
                        </div>
                    {% elif message.message_type == 'video' %}
                        <div class="media-container">
                            <video controls style="max-width: 200px;">
                                <source src="{{ message.media_url }}" type="video/mp4">
                            </video>
                        </div>
                    {% elif message.message_type == 'audio' %}
                        <div class="media-container">
                            <audio controls>
                                <source src="{{ message.media_url }}" type="audio/mpeg">
                            </audio>
                        </div>
                    {% elif message.message_type == 'document' %}
                        <div class="media-container">
                            <a href="{{ message.media_url }}" target="_blank" class="btn btn-outline">
                                üìÑ Abrir documento
                            </a>
                        </div>
                    {% endif %}
                {% endif %}
            </div>
        </div>
        {% empty %}
        <div style="text-align: center; color: #666; padding: 2rem;">
            No hay mensajes en esta conversaci√≥n
        </div>
        {% endfor %}
    </div>

    <div class="message-input-container">
        <div class="input-controls">
            <button class="btn btn-secondary" onclick="openTemplatesModal()" title="Usar plantillas">
                üìù Plantillas
            </button>
            <button class="btn btn-secondary" onclick="openFileUpload()" title="Subir archivos">
                üìé Adjuntar
            </button>
            <input type="file" id="fileInput" style="display: none;" accept="image/*,video/*,audio/*,.pdf,.doc,.docx" onchange="handleFileSelect(event)">
        </div>
        <div class="message-input-wrapper">
            <textarea id="messageInput" placeholder="Escribe tu mensaje aqu√≠..." rows="3"></textarea>
        </div>
        <button class="btn btn-primary" onclick="sendMessage()" id="sendBtn">Enviar</button>
    </div>
</div>

<!-- Alerta de tiempo de respuesta -->
<div id="responseTimeAlert" class="response-time-alert">
    <button class="close-alert" onclick="closeResponseAlert()">&times;</button>
    <div id="alertContent">
        ‚ö†Ô∏è <strong>Tiempo de respuesta:</strong>
        <div id="alertMessage"></div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
const conversationId = {{ conversation.id }};
const platform = '{{ conversation.contact.platform.name }}';
const recipientId = '{{ conversation.contact.platform_user_id }}';

function openWhatsApp(phoneNumber) {
    if (phoneNumber) {
        window.open(`https://wa.me/${phoneNumber}`, '_blank');
    }
}

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Funci√≥n robusta para obtener CSRF token de m√∫ltiples fuentes
function getCSRFToken() {
    // 1. Intentar desde cookie
    let token = getCookie('csrftoken');
    if (token) {
        console.log('üîë CSRF token encontrado en cookie:', token.substring(0, 10) + '...');
        return token;
    }
    
    // 2. Intentar desde meta tag
    const metaTag = document.querySelector('meta[name="csrf-token"]');
    if (metaTag) {
        token = metaTag.getAttribute('content');
        console.log('üîë CSRF token encontrado en meta tag:', token.substring(0, 10) + '...');
        return token;
    }
    
    // 3. Intentar desde input hidden
    const hiddenInput = document.querySelector('input[name="csrfmiddlewaretoken"]');
    if (hiddenInput) {
        token = hiddenInput.value;
        console.log('üîë CSRF token encontrado en input hidden:', token.substring(0, 10) + '...');
        return token;
    }
    
    console.error('‚ùå No se pudo encontrar CSRF token en ninguna fuente');
    return null;
}

function sendMessage() {
    const input = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendBtn');
    const message = input.value.trim();
    
    if (!message) {
        alert('Por favor escribe un mensaje');
        return;
    }
    
    sendButton.disabled = true;
    sendButton.textContent = 'Enviando...';
    
    fetch('/api/whatsapp/send-message/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            conversation_id: conversationId,
            message: message,
            platform: platform,
            recipient_id: recipientId
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // üöÄ Crear y mostrar el mensaje inmediatamente
            const messageData = {
                sender_name: 'T√∫', // Nombre del agente actual
                sender_type: 'agent',
                content: message,
                created_at: new Date().toISOString(),
                message_type: 'text'
            };
            
            const messageElement = createMessageElement(messageData);
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.appendChild(messageElement);
            
            // üéØ SIEMPRE scroll al final cuando env√≠as
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            input.value = '';
            console.log('‚úÖ Mensaje enviado y mostrado inmediatamente - SIN retraso');
            
            // Actualizar contador para evitar duplicados cuando llegue la respuesta del servidor
            chatLastMessageCount++;
        } else {
            alert('Error al enviar mensaje: ' + (data.error || 'Error desconocido'));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error al enviar mensaje');
    })
    .finally(() => {
        sendButton.disabled = false;
        sendButton.textContent = 'Enviar';
    });
}

function loadMessages() {
    console.log('üîÑ Actualizando mensajes despu√©s de enviar...');
    // Usar el mismo sistema que cuando se reciben mensajes (sin reload)
    setTimeout(() => {
        checkForNewMessages(); // Usa la misma funci√≥n que para mensajes entrantes
    }, 200);
}

// Enter para enviar mensaje
document.getElementById('messageInput').addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
    }
});

// Funciones para plantillas
function openTemplatesModal() {
    // Abrir modal de plantillas o redirigir a la p√°gina de plantillas
    window.open('/templates/', '_blank');
}

        // Sistema de auto-refresh para mensajes
        let chatAutoRefreshEnabled = true;
        let chatAutoRefreshInterval = null;
        let chatLastMessageCount = {{ messages|length }};
        let justSentMessage = false; // Flag para saber si acabamos de enviar un mensaje

        // üîß Funci√≥n global para corregir URLs de media
        function fixMediaUrl(url) {
            if (!url) return url;
            
            // Detectar URLs duplicadas
            if (url.includes('http://localhost:8000http://')) {
                let parts = url.split('/media/');
                if (parts.length > 1) {
                    url = `http://192.168.1.176:8000/media/${parts[parts.length - 1]}`;
                }
            }
            // Cambiar localhost por IP de red
            else if (url.startsWith('http://localhost:8000')) {
                url = url.replace('http://localhost:8000', 'http://192.168.1.176:8000');
            }
            // Convertir URLs relativas a absolutas
            else if (url.startsWith('/media/')) {
                url = `http://192.168.1.176:8000${url}`;
            }
            
            return url;
        }

        // üîß Funci√≥n global para escapar HTML
        function escapeHtml(text) {
            if (!text) return '';
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, function(m) { return map[m]; });
        }

        // üèóÔ∏è Funci√≥n para crear elemento de mensaje (mensajes enviados inmediatamente)
        function createMessageElement(messageData) {
            const messageDiv = document.createElement('div');
            // Usar la clase CSS correcta: message-sent para agentes, message-received para usuarios
            const messageClass = messageData.sender_type === 'agent' ? 'message-sent' : 'message-received';
            messageDiv.className = `message ${messageClass}`;
            
            const timestamp = new Date(messageData.created_at).toLocaleString('es-ES', {
                day: '2-digit', month: '2-digit', year: 'numeric',
                hour: '2-digit', minute: '2-digit'
            });
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <strong>${messageData.sender_name}</strong>
                    <span class="message-date">${timestamp}</span>
                </div>
                <div class="message-content">${messageData.content}</div>
            `;
            
            return messageDiv;
        }

        // üèóÔ∏è Funci√≥n para crear elemento desde objeto del servidor
        function createMessageFromObject(message) {
            const messageDiv = document.createElement('div');
            // Usar la clase CSS correcta: message-sent para agentes, message-received para usuarios
            const messageClass = message.sender_type === 'agent' ? 'message-sent' : 'message-received';
            messageDiv.className = `message ${messageClass}`;
            
            const timestamp = new Date(message.created_at).toLocaleString('es-ES', {
                day: '2-digit', month: '2-digit', year: 'numeric',
                hour: '2-digit', minute: '2-digit'
            });
            
            let messageHTML = `
                <div class="message-header">
                    <strong>${escapeHtml(message.sender_name)}</strong>
                    <span class="message-date">${timestamp}</span>
                </div>
                <div class="message-content">
                    ${message.content ? escapeHtml(message.content) : ''}
            `;
            
            // Agregar multimedia si existe
            if (message.media_url) {
                const correctedMediaUrl = fixMediaUrl(message.media_url);
                
                if (message.message_type === 'image') {
                    messageHTML += `
                        <div class="media-container">
                            <img src="${correctedMediaUrl}" alt="Imagen" style="max-width: 200px; border-radius: 4px;" onload="setTimeout(() => { const container = document.getElementById('messagesContainer'); if (container) container.scrollTop = container.scrollHeight; }, 50);">
                        </div>
                    `;
                } else if (message.message_type === 'video') {
                    messageHTML += `
                        <div class="media-container">
                            <video controls style="max-width: 200px;">
                                <source src="${correctedMediaUrl}" type="video/mp4">
                                Tu navegador no soporta la reproducci√≥n de video.
                            </video>
                        </div>
                    `;
                } else if (message.message_type === 'audio') {
                    messageHTML += `
                        <div class="media-container">
                            <audio controls>
                                <source src="${correctedMediaUrl}" type="audio/mpeg">
                                Tu navegador no soporta la reproducci√≥n de audio.
                            </audio>
                        </div>
                    `;
                } else if (message.message_type === 'document') {
                    messageHTML += `
                        <div class="media-container">
                            <a href="${correctedMediaUrl}" target="_blank" class="btn btn-outline">
                                üìÑ Abrir documento
                            </a>
                        </div>
                    `;
                }
            }
            
            messageHTML += `</div>`; // Cerrar message-content
            
            messageDiv.innerHTML = messageHTML;
            return messageDiv;
        }function checkForNewMessages() {
    console.log(`üîç Verificando nuevos mensajes... (actual: ${chatLastMessageCount})`);
    
    fetch(`/api/conversations/${conversationId}/messages/`, {
        method: 'GET',
        credentials: 'same-origin',
        headers: {
            'X-CSRFToken': getCSRFToken()
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log(`üìä Respuesta API: ${data.messages.length} mensajes`);
            if (data.messages.length > chatLastMessageCount) {
                console.log(`üîÑ ¬°${data.messages.length - chatLastMessageCount} nuevos mensajes detectados!`);
                // Solo agregar los mensajes nuevos
                const newMessages = data.messages.slice(chatLastMessageCount);
                appendNewMessages(newMessages, justSentMessage); // Pasar flag de si acabamos de enviar
                chatLastMessageCount = data.messages.length;
                
                // Reset del flag despu√©s de procesar
                if (justSentMessage) {
                    justSentMessage = false;
                    console.log('üîÑ Flag justSentMessage reseteado');
                }
                
                // Actualizar estado de conversaci√≥n si es necesario
                updateConversationStatus(data.conversation_status);
            } else {
                console.log('‚úÖ No hay mensajes nuevos');
            }
        } else {
            console.error('‚ùå Error en respuesta API:', data.error);
        }
    })
    .catch(error => {
        console.error('‚ùå Error checking messages:', error);
    });
}

        function appendNewMessages(newMessages, sentByUser = false) {
            // Verificar si es un array de mensajes (objetos) o HTML string
            if (Array.isArray(newMessages) && newMessages.length > 0) {
                console.log(`üì® Agregando ${newMessages.length} nuevos mensajes al DOM`);
                
                // Verificar si hay multimedia en los mensajes
                let hasMedia = newMessages.some(msg => msg.media_url && msg.message_type === 'image');
                
                newMessages.forEach(message => {
                    const messageElement = createMessageFromObject(message);
                    messagesContainer.appendChild(messageElement);
                });
                
                // üéØ SIEMPRE hacer scroll al final para cualquier mensaje nuevo
                console.log('üì® Nuevos mensajes - SIEMPRE scroll al final');
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                // üì∏ Si hay im√°genes, hacer scroll adicional despu√©s de un peque√±o delay
                if (hasMedia) {
                    console.log('üì∏ Imagen detectada - aplicando scrolls m√∫ltiples');
                    
                    setTimeout(() => {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        console.log('üì∏ Scroll a los 200ms');
                    }, 200);
                    
                    setTimeout(() => {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        console.log('üì∏ Scroll a los 500ms');
                    }, 500);
                    
                    setTimeout(() => {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        console.log('ÔøΩ Scroll adicional para im√°genes aplicado');
                    }, 1200);
                }
                
            } else if (typeof newMessages === 'string' && newMessages.trim()) {
                // Compatibilidad con HTML strings (si a√∫n se usan en alg√∫n lugar)
                messagesContainer.innerHTML += newMessages;
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }// Funci√≥n ensureAtBottom removida - CSS flexbox maneja posicionamiento autom√°ticamente

// Funciones de auto-scroll simplificadas removidas - Solo scroll autom√°tico siempre

function updateConversationStatus(status) {
    // Actualizar elementos de la UI basados en el estado de la conversaci√≥n
    if (status) {
        console.log('Estado de conversaci√≥n actualizado:', status);
        // Aqu√≠ podr√≠as actualizar badges o indicadores visuales si los tienes
    }
}

// Funci√≥n de respaldo para recargar todos los mensajes (por si acaso)
function updateMessagesDisplay(messages) {
    const messagesContainer = document.getElementById('messagesContainer');
    const wasAtBottom = messagesContainer.scrollHeight - messagesContainer.clientHeight <= messagesContainer.scrollTop + 1;
    
    // Limpiar mensajes actuales
    messagesContainer.innerHTML = '';
    
    // Agregar todos los mensajes
    messages.forEach(message => {
        const messageElement = createMessageElement(message);
        messagesContainer.appendChild(messageElement);
    });
    
    // Mantener scroll en el bottom si ya estaba all√≠
    if (wasAtBottom) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    // Actualizar tiempo de respuesta
    initResponseTimeMonitoring();
}

// C√≥digo duplicado eliminado - usando funciones globales definidas arriba

function startChatAutoRefresh() {
    if (chatAutoRefreshInterval) {
        clearInterval(chatAutoRefreshInterval);
    }
    chatAutoRefreshInterval = setInterval(checkForNewMessages, 3000); // Cada 3 segundos
    console.log('‚úÖ Chat auto-refresh activado - verificando cada 3 segundos');
    console.log(`üìä Conteo inicial de mensajes: ${chatLastMessageCount}`);
}

function stopChatAutoRefresh() {
    if (chatAutoRefreshInterval) {
        clearInterval(chatAutoRefreshInterval);
        chatAutoRefreshInterval = null;
        console.log('‚è∏Ô∏è Chat auto-refresh pausado');
    }
}

// Funciones para manejo de archivos
function openFileUpload() {
    document.getElementById('fileInput').click();
}

function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file) {
        // Mostrar preview del archivo seleccionado
        const fileName = file.name;
        const fileSize = (file.size / 1024 / 1024).toFixed(2); // MB
        
        if (confirm(`¬øDeseas enviar el archivo "${fileName}" (${fileSize} MB)?`)) {
            uploadFile(file);
        }
    }
}

function uploadFile(file) {
    // Detectar tipo de archivo autom√°ticamente
    function detectFileType(filename) {
        const extension = filename.split('.').pop().toLowerCase();
        const fileTypes = {
            'image': ['jpg', 'jpeg', 'png', 'gif', 'webp'],
            'video': ['mp4', 'avi', 'mov', 'wmv', 'webm'],
            'audio': ['mp3', 'wav', 'ogg', 'm4a', 'aac'],
            'document': ['pdf', 'doc', 'docx', 'txt', 'xlsx', 'pptx']
        };
        
        for (const [type, extensions] of Object.entries(fileTypes)) {
            if (extensions.includes(extension)) {
                return type;
            }
        }
        return 'document'; // Tipo por defecto
    }
    
    const fileType = detectFileType(file.name);
    console.log(`üìé Detectado tipo de archivo: ${fileType} para ${file.name}`);
    
    const formData = new FormData();
    formData.append('file', file);
    formData.append('conversation_id', conversationId);
    formData.append('platform', platform);
    formData.append('recipient', recipientId);
    formData.append('file_type', fileType);
    
    // Mostrar indicador de carga
    const sendButton = document.getElementById('sendBtn');
    const originalText = sendButton.textContent;
    sendButton.disabled = true;
    sendButton.textContent = 'Enviando archivo...';
    
    const csrfToken = getCSRFToken();
    console.log('üîë Token CSRF obtenido:', csrfToken ? 'S√ç' : 'NO');
    if (!csrfToken) {
        console.error('‚ùå Error: No se pudo obtener token CSRF');
        alert('Error: No se pudo obtener token CSRF');
        sendButton.disabled = false;
        sendButton.textContent = originalText;
        return;
    }
    
    console.log('üì§ Preparando env√≠o de archivo...');
    console.log('üìã Datos:', {
        file: file.name,
        size: file.size + ' bytes',
        type: fileType,
        conversationId: conversationId,
        platform: platform || 'No definido',
        recipient: recipientId || 'No definido'
    });
    
    let uploadUrl = '/api/send-file-message/';
    
    console.log('üåê URL de upload:', uploadUrl);
    console.log('üì¶ FormData construido, enviando...');
    
    fetch(uploadUrl, {
        method: 'POST',
        headers: {
            'X-CSRFToken': csrfToken
        },
        body: formData
    })
    .then(response => {
        console.log('üì° Respuesta del servidor:', response.status, response.statusText);
        if (!response.ok) {
            return response.text().then(text => {
                console.error('‚ùå Error del servidor:', text);
                throw new Error(`HTTP ${response.status}: ${response.statusText} - ${text}`);
            });
        }
        return response.json();
    })
    .then(data => {
        console.log('üìÑ Respuesta JSON:', data);
        if (data.success) {
            // Limpiar input de archivo
            document.getElementById('fileInput').value = '';
            console.log('‚úÖ Archivo enviado exitosamente, recargando p√°gina...');
            alert('¬°Archivo enviado correctamente! La p√°gina se recargar√° para mostrar el mensaje.');
            loadMessages(); // Recargar mensajes
        } else {
            console.error('‚ùå Error en respuesta:', data.error);
            alert('Error al enviar archivo: ' + (data.error || 'Error desconocido'));
        }
    })
    .catch(error => {
        console.error('‚ùå Error en catch:', error);
        alert('Error al enviar archivo: ' + error.message);
    })
    .finally(() => {
        sendButton.disabled = false;
        sendButton.textContent = originalText;
    });
}

// Sistema de alertas de tiempo de respuesta
let responseTimeInterval;
let lastMessageTime = null;

function initResponseTimeMonitoring() {
    // Encontrar el √∫ltimo mensaje del contacto (no del agente)
    const messages = document.querySelectorAll('.message-received');
    if (messages.length > 0) {
        const lastMessage = messages[messages.length - 1];
        const timeElement = lastMessage.querySelector('small');
        if (timeElement) {
            // Extraer la fecha del √∫ltimo mensaje
            const messageTime = parseMessageTime(timeElement.textContent);
            if (messageTime) {
                lastMessageTime = messageTime;
                startResponseTimeCheck();
            }
        }
    }
}

function parseMessageTime(timeString) {
    // Formato esperado: "dd/mm/yyyy HH:mm"
    try {
        const [datePart, timePart] = timeString.trim().split(' ');
        const [day, month, year] = datePart.split('/');
        const [hours, minutes] = timePart.split(':');
        
        return new Date(year, month - 1, day, hours, minutes);
    } catch (e) {
        console.error('Error parsing message time:', e);
        return null;
    }
}

function startResponseTimeCheck() {
    if (responseTimeInterval) {
        clearInterval(responseTimeInterval);
    }
    
    responseTimeInterval = setInterval(function() {
        if (!lastMessageTime) return;
        
        const now = new Date();
        const timeDiff = (now - lastMessageTime) / 1000; // segundos
        
        if (timeDiff >= 60 && timeDiff < 300) { // 1-5 minutos
            showResponseAlert('Han pasado m√°s de 1 minuto sin responder', 'warning');
        } else if (timeDiff >= 300 && timeDiff < 600) { // 5-10 minutos
            showResponseAlert('Han pasado m√°s de 5 minutos sin responder', 'danger');
        } else if (timeDiff >= 600) { // m√°s de 10 minutos
            showResponseAlert('Han pasado m√°s de 10 minutos sin responder', 'danger');
        }
    }, 30000); // Verificar cada 30 segundos
}

function showResponseAlert(message, type = 'warning') {
    const alert = document.getElementById('responseTimeAlert');
    const messageElement = document.getElementById('alertMessage');
    
    messageElement.textContent = message;
    alert.className = `response-time-alert ${type}`;
    alert.style.display = 'block';
    
    // Auto-ocultar despu√©s de 10 segundos
    setTimeout(() => {
        if (alert.style.display === 'block') {
            alert.style.display = 'none';
        }
    }, 10000);
}

function closeResponseAlert() {
    document.getElementById('responseTimeAlert').style.display = 'none';
}

// üéØ Inicializaci√≥n con scroll al final al cargar
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Iniciando sistema con scroll funcional...');
    
    // Scroll inicial al final
    const messagesContainer = document.getElementById('messagesContainer');
    if (messagesContainer) {
        setTimeout(() => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            console.log('üìú Scroll inicial al final completado');
        }, 100);
    }
    
    // Inicializar monitoreo de tiempo de respuesta
    initResponseTimeMonitoring();
    
    // Inicializar auto-refresh del chat
    console.log('üîÑ Iniciando sistema de auto-refresh...');
    console.log(`üìä Estado inicial - Mensajes: ${chatLastMessageCount}, Siempre activo: ${chatAutoRefreshEnabled}`);
    startChatAutoRefresh();
    
    // üéØ Auto-scroll peri√≥dico solo cuando llegan mensajes nuevos
    // (removido el scroll autom√°tico constante para permitir navegaci√≥n manual)
    
    // Auto-refresh siempre activo - sin pausas por escritura
    console.log('üîÑ Auto-refresh configurado para estar siempre activo');
});

// Limpiar intervals al salir de la p√°gina
window.addEventListener('beforeunload', function() {
    if (responseTimeInterval) {
        clearInterval(responseTimeInterval);
    }
    if (chatAutoRefreshInterval) {
        clearInterval(chatAutoRefreshInterval);
    }
});

// Funci√≥n global para corregir URLs de media para acceso desde red local
function fixAllMediaUrls() {
    // Corregir todas las im√°genes
    document.querySelectorAll('img[src*="/media/"], img[src*="localhost:8000"]').forEach(img => {
        let src = img.src;
        if (src.includes('http://localhost:8000http://')) {
            let parts = src.split('/media/');
            if (parts.length > 1) {
                img.src = `http://192.168.1.176:8000/media/${parts[parts.length - 1]}`;
            }
        } else if (src.includes('localhost:8000')) {
            img.src = src.replace('http://localhost:8000', 'http://192.168.1.176:8000');
        }
    });
    
    // Corregir todos los audios y videos
    document.querySelectorAll('audio source[src*="/media/"], audio source[src*="localhost:8000"], video source[src*="/media/"], video source[src*="localhost:8000"]').forEach(source => {
        let src = source.src;
        if (src.includes('http://localhost:8000http://')) {
            let parts = src.split('/media/');
            if (parts.length > 1) {
                source.src = `http://192.168.1.176:8000/media/${parts[parts.length - 1]}`;
            }
        } else if (src.includes('localhost:8000')) {
            source.src = src.replace('http://localhost:8000', 'http://192.168.1.176:8000');
        }
        // Recargar el elemento multimedia
        source.parentNode.load();
    });
    
    // Corregir todos los enlaces
    document.querySelectorAll('a[href*="/media/"], a[href*="localhost:8000"]').forEach(link => {
        let href = link.href;
        if (href.includes('http://localhost:8000http://')) {
            let parts = href.split('/media/');
            if (parts.length > 1) {
                link.href = `http://192.168.1.176:8000/media/${parts[parts.length - 1]}`;
            }
        } else if (href.includes('localhost:8000')) {
            link.href = href.replace('http://localhost:8000', 'http://192.168.1.176:8000');
        }
    });
}

// Ejecutar correcci√≥n al cargar la p√°gina
document.addEventListener('DOMContentLoaded', fixAllMediaUrls);

// Tambi√©n ejecutar despu√©s de cada actualizaci√≥n de mensajes
const originalLoadMessages = loadMessages;
if (typeof loadMessages === 'function') {
    loadMessages = function(...args) {
        originalLoadMessages.apply(this, args);
        setTimeout(fixAllMediaUrls, 500); // Dar tiempo para que se rendericen los elementos
    };
}

// Aplicar correcci√≥n de URLs tambi√©n despu√©s del auto-refresh
const originalAppendNewMessages = appendNewMessages;
if (typeof appendNewMessages === 'function') {
    appendNewMessages = function(newMessages) {
        originalAppendNewMessages.call(this, newMessages);
        setTimeout(fixAllMediaUrls, 200); // Corregir URLs de mensajes nuevos
    };
}

// Aplicar correcci√≥n despu√©s de updateMessagesDisplay
const originalUpdateMessagesDisplay = updateMessagesDisplay;
if (typeof updateMessagesDisplay === 'function') {
    updateMessagesDisplay = function(messages) {
        originalUpdateMessagesDisplay.call(this, messages);
        setTimeout(fixAllMediaUrls, 200); // Corregir URLs de todos los mensajes
    };
}
</script>
{% endblock %}